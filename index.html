<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThreeJS Study</title>
</head>
<body>
    <canvas id="c"></canvas>

    <script  type="importmap"> 
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js"
            }
        }
    </script>

    <!-- type을 module로 해야 import 키워드를 사용할 수 있다 -->
    <script type="module">
        // Three.js 로드
        import * as THREE from 'three';

        function main() {
            // c라는 id의 캔버스 객체를 가져옴.
            const canvas = document.querySelector("#c");
            // 지정한 캔버스에 렌더링. canvas를 지정하지 않고 동적으로 자동으로 생성되는 캔버스를 document에 넣을 수 있음
            const renderer = new THREE.WebGLRenderer({antialias: true, canvas});

            // 원근 카메라 생성
            const fov = 75;     // field of view(시야각) 수직면 75도로 설정(원근 카메라만 degree 사용, 나머지는 radian 사용)
            const aspect = 2;   // 가로 세로 비율(캔버스 기본 설정 크기가 300x150이라서 300/150=2를 설정)
            const near = 0.1;   // 카메라 앞에 렌더링 되는 공간 범위. 이 공간을 넘어간 요소는 렌더링 되지 않음
            const far = 5;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

            // 카메라 위치 설정
            camera.position.z = 2;

            // Scene 객체 생성
            const scene = new THREE.Scene();

            // 정육면체를 만들기 위한 정점 데이터와 geometry
            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

            // metarial 생성
            const material = new THREE.MeshBasicMaterial({color: 0x44aa88});

            // Mesh 생성(Meah는 Geometry, Meterial 외에도 물체의 크기, 위치, 방향을 담은 객체)
            const cube = new THREE.Mesh(geometry, material);

            // Scene 객체에 Mesh 객체를 넣음
            scene.add(cube);

            // 렌더링
            renderer.render(scene, camera);

            function render(time) {
                time *= 0.001;

                cube.rotation.x = time;
                cube.rotation.y = time;
                
                renderer.render(scene, camera);

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }

        main()
    </script>
</body>
</html>